<?php

/**
 * @file
 * Contains lending_library.module.
 *
 * IMPORTANT: When running Lando commands, please execute them from the project root directory
 * (/mnt/extra_storage/makehaven-webdev/dev.makehaven-website/),
 * not from within this module directory.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Url;
use Drupal\node\NodeInterface;
use Drupal\Core\Link;
use Drupal\user\Entity\User;
use Drupal\lending_library\Service\LendingLibraryManager;

// --- CONFIGURATION CONSTANTS ---
define('LENDING_LIBRARY_ITEM_NODE_TYPE', 'library_item');

define('LENDING_LIBRARY_ITEM_STATUS_FIELD', 'field_library_item_status');
define('LENDING_LIBRARY_ITEM_BORROWER_FIELD', 'field_library_item_borrower');
define('LENDING_LIBRARY_ITEM_WAITLIST_FIELD', 'field_library_item_waitlist');
define('LENDING_LIBRARY_ITEM_REQUIRES_BATTERIES_FIELD', 'field_library_item_uses_battery');
define('LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD', 'field_library_item_replacement_v');

define('LENDING_LIBRARY_TRANSACTION_ACTION_FIELD', 'field_library_action');
define('LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD', 'field_library_item');
define('LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD', 'field_library_borrower');
define('LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD', 'field_library_inspection_issues');
define('LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD', 'field_library_return_date');
define('LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD', 'field_library_return_inspect_img');
define('LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD', 'field_library_borrow_date');
define('LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD', 'field_library_due_date');
define('LENDING_LIBRARY_TRANSACTION_RENEW_COUNT_FIELD', 'field_library_renew_count');
define('LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD', 'field_library_borrow_batteries');

define('LENDING_LIBRARY_ITEM_STATUS_AVAILABLE', 'available');
define('LENDING_LIBRARY_ITEM_STATUS_BORROWED', 'borrowed');
define('LENDING_LIBRARY_ITEM_STATUS_MISSING', 'missing');
define('LENDING_LIBRARY_ITEM_STATUS_REPAIR', 'repair');
define('LENDING_LIBRARY_ITEM_STATUS_RETIRED', 'retired');

define('LENDING_LIBRARY_ACTION_WITHDRAW', 'withdraw');
define('LENDING_LIBRARY_ACTION_RENEW', 'renew');
define('LENDING_LIBRARY_ACTION_RETURN', 'return');
define('LENDING_LIBRARY_ACTION_ISSUE', 'issue');

define('LENDING_LIBRARY_INSPECTION_NO_ISSUES', 'no_issues');
define('LENDING_LIBRARY_INSPECTION_DAMAGE', 'damage');
define('LENDING_LIBRARY_INSPECTION_MISSING', 'missing');
define('LENDING_LIBRARY_INSPECTION_OTHER', 'other');

define('LENDING_LIBRARY_BATTERY_STATUS_FIELD', 'field_battery_status');
define('LENDING_LIBRARY_BATTERY_BORROWER_FIELD', 'field_battery_borrower');
define('LENDING_LIBRARY_BATTERY_CURRENT_ITEM_FIELD', 'field_battery_current_item');
define('LENDING_LIBRARY_BATTERY_STATUS_AVAILABLE', 'available');
define('LENDING_LIBRARY_BATTERY_STATUS_BORROWED', 'borrowed');
define('LENDING_LIBRARY_BATTERY_STATUS_MISSING', 'missing');
define('LENDING_LIBRARY_BATTERY_STATUS_RETIRED', 'retired');


// --- END CONFIGURATION CONSTANTS ---


/**
 * Helper: get status, borrower, and replacement value from the library_item node.
 * @deprecated Use \Drupal::service('lending_library.manager')->getItemDetails() instead.
 */
function _lending_library_get_item_details(NodeInterface $library_item_node = NULL) {
  return \Drupal::service('lending_library.manager')->getItemDetails($library_item_node);
}

/**
 * Sends a "due soon" email.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendDueSoonEmail() instead.
 */
function _lending_library_send_due_soon_email(EntityInterface $transaction) {
  \Drupal::service('lending_library.manager')->sendDueSoonEmail($transaction);
}

/**
 * Helper: get current loan borrow/due dates from latest withdraw transaction.
 * @deprecated Use \Drupal::service('lending_library.manager')->getCurrentLoanDetails() instead.
 */
function _lending_library_get_current_loan_details(NodeInterface $library_item_node) {
  return \Drupal::service('lending_library.manager')->getCurrentLoanDetails($library_item_node);
}


/**
 * Load batteries currently borrowed for a given item + borrower.
 * @deprecated Use \Drupal::service('lending_library.manager')->loadBorrowedBatteries() instead.
 */
function _lending_library_load_borrowed_batteries($item_nid, $borrower_uid) {
  return \Drupal::service('lending_library.manager')->loadBorrowedBatteries($item_nid, $borrower_uid);
}

/**
 * Mark the provided batteries as returned (available + clear borrower/item).
 * @deprecated Use \Drupal::service('lending_library.manager')->returnBatteries() instead.
 */
function _lending_library_return_batteries(array $batteries) {
  \Drupal::service('lending_library.manager')->returnBatteries($batteries);
}

/**
 * Submit handler to check for manual damage charges and redirect to a confirmation form.
 */
function _lending_library_check_for_damage_charge_submit(array &$form, FormStateInterface $form_state) {
  $transaction = $form_state->getFormObject()->getEntity();

  // Ensure we have the original entity to compare against.
  if (!isset($transaction->original)) {
    return;
  }
  $original_transaction = $transaction->original;

  $is_damage_transaction = FALSE;
  if ($transaction->hasField('field_library_inspection_issues') && $transaction->get('field_library_inspection_issues')->value === 'damage') {
    $is_damage_transaction = TRUE;
  }

  if (!$is_damage_transaction) {
    return;
  }

  $original_amount_due = 0;
  if ($original_transaction->hasField('field_library_amount_due') && !$original_transaction->get('field_library_amount_due')->isEmpty()) {
    $original_amount_due = $original_transaction->get('field_library_amount_due')->value;
  }

  $new_amount_due = 0;
  if ($transaction->hasField('field_library_amount_due') && !$transaction->get('field_library_amount_due')->isEmpty()) {
    $new_amount_due = $transaction->get('field_library_amount_due')->value;
  }

  // If the amount due was increased, redirect to the confirmation form.
  if ($new_amount_due > 0 && $new_amount_due > $original_amount_due) {
    $form_state->setRedirectUrl($transaction->toUrl('canonical')->setRouteParameter('library_transaction', $transaction->id())->setRouteName('lending_library.damage_charge_confirm'));
  }
}


/**
 * Implements hook_form_FORM_ID_alter() for the library_transaction entity form.
 */
function lending_library_form_library_transaction_library_transaction_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();
  if (method_exists($form_object, 'getEntity')) {
    $transaction_entity = $form_object->getEntity();
    if ($transaction_entity && $transaction_entity->getEntityTypeId() === 'library_transaction' && $transaction_entity->bundle() === 'library_transaction') {
      _lending_library_transaction_form_logic($form, $form_state, $transaction_entity);
    }
  }
}

/**
 * Apply conditional logic and defaults to library transaction forms.
 */
function _lending_library_transaction_form_logic(&$form, FormStateInterface $form_state, EntityInterface $transaction_entity) {
  $current_user = \Drupal::currentUser();
  $library_item_node = NULL;
  $tool_requires_batteries = FALSE;
  $item_details = NULL;

  if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->isEmpty()) {
    $library_item_node_id = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->target_id;
    if ($library_item_node_id) {
      $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($library_item_node_id);
      if ($library_item_node instanceof NodeInterface) {
        $item_details = _lending_library_get_item_details($library_item_node);
        if ($library_item_node->hasField(LENDING_LIBRARY_ITEM_REQUIRES_BATTERIES_FIELD) && !$library_item_node->get(LENDING_LIBRARY_ITEM_REQUIRES_BATTERIES_FIELD)->isEmpty()) {
          $tool_requires_batteries = (bool) $library_item_node->get(LENDING_LIBRARY_ITEM_REQUIRES_BATTERIES_FIELD)->value;
        }
      }
    }
  }

  $route_match = \Drupal::routeMatch();
  $predefined_action = $route_match->getParameter('action_type');

  $current_action = $predefined_action;
  if (!$current_action) {
    $action_field_value_from_state = $form_state->getValue(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD);
    if (is_array($action_field_value_from_state) && isset($action_field_value_from_state[0]['value'])) {
      $current_action = $action_field_value_from_state[0]['value'];
    }
    elseif (!is_array($action_field_value_from_state) && !empty($action_field_value_from_state)) {
      $current_action = $action_field_value_from_state;
    }
    elseif ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->isEmpty()) {
      $current_action = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->value;
    }
  }

  // If routed with an explicit action, force it on the entity, hide the widget,
  // and set widget default so the saved value is correct.
  if ($predefined_action && isset($form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD])) {
    $transaction_entity->set(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, $predefined_action);
    if (isset($form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['widget'])) {
      $form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['widget']['#default_value'] = $predefined_action;
    }
    $form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['#access'] = FALSE;
  }

  if ($library_item_node) {
    $info_markup = '<div class="lending-library-form-info">';
    $info_markup .= '<h3>' . $library_item_node->label() . '</h3>';

    $location_parts = [];
    if ($library_item_node->hasField('field_library_location_row_item') && !$library_item_node->get('field_library_location_row_item')->isEmpty()) {
      $location_parts[] = t('Row: @row', ['@row' => $library_item_node->get('field_library_location_row_item')->value]);
    }
    if ($library_item_node->hasField('field_library_location_shelf_num') && !$library_item_node->get('field_library_location_shelf_num')->isEmpty()) {
      $location_parts[] = t('Shelf: @shelf', ['@shelf' => $library_item_node->get('field_library_location_shelf_num')->value]);
    }
    if (!empty($location_parts)) {
      $info_markup .= '<div class="location">' . implode(', ', $location_parts) . '</div>';
    }
    $info_markup .= '</div>';

    $form['tool_info'] = [
      '#markup' => $info_markup,
      '#weight' => -100,
    ];
  }

  if ($predefined_action) {
    switch ($predefined_action) {
      case LENDING_LIBRARY_ACTION_WITHDRAW:
        // Hide fields not edited on Withdraw.
        if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#access'] = FALSE;
        if (isset($form['field_library_inspection_notes'])) $form['field_library_inspection_notes']['#access'] = FALSE;

        // Enable camera capture for the borrow inspection image.
        if (isset($form['field_library_borrow_inspect_img']['widget'][0])) {
          $form['field_library_borrow_inspect_img']['widget'][0]['#process'][] = '_lending_library_add_capture_attribute';
        }
        break;

        case LENDING_LIBRARY_ACTION_RETURN:
          // Hide borrow/due on Return.
          if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD]['#access'] = FALSE;
          if (isset($form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD]['#access'] = FALSE;
          if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD]['#access'] = FALSE;
          if (isset($form['field_library_borrow_inspect_img'])) $form['field_library_borrow_inspect_img']['#access'] = FALSE;
                  if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD]['#disabled'] = TRUE;
          
                  // Enable camera capture for the return inspection image.
                  if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD]['widget'][0])) {
                    $form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD]['widget'][0]['#process'][] = '_lending_library_add_capture_attribute';
                  }
          
                  if (isset($form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD])) {            $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#title'] = t('Did you have any issues with this tool?');
            $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#required'] = TRUE;
            $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['widget']['#default_value'] = LENDING_LIBRARY_INSPECTION_NO_ISSUES;
          }
          if (isset($form['field_library_inspection_notes'])) {
            $form['field_library_inspection_notes']['#title'] = t('If you had issues, please describe them');
          }
  
          // Offer to also return associated batteries (if any).
          if ($library_item_node instanceof \Drupal\node\NodeInterface) {
            $borrower_uid = \Drupal::currentUser()->id();
            if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)->isEmpty()) {
              $borrower_uid = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)->target_id;
            }
  
            $bats = _lending_library_load_borrowed_batteries($library_item_node->id(), $borrower_uid);
            if (!empty($bats)) {
              // Render a small list as a reminder.
              $items = [];
              foreach ($bats as $bat) {
                $items[] = $bat->label() . ' (ID ' . $bat->id() . ')';
              }
              $form['lending_library_return_batteries'] = [
                '#type' => 'checkbox',
                '#title' => t('Also return associated batteries'),
                '#default_value' => 1,
                '#weight' => 20,
                '#description' => [
                  '#type' => 'markup',
                  '#markup' => '<div class="description"><strong>' . t('Batteries to return:') . '</strong><br/>' . implode('<br/>', array_map('htmlspecialchars', $items)) . '</div>',
                ],
              ];
            }
          }
          break;
  
  

      case LENDING_LIBRARY_ACTION_ISSUE:
        if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_BORROW_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD]['#access'] = FALSE;
        if (isset($form['field_library_borrow_inspect_img'])) $form['field_library_borrow_inspect_img']['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD]['#access'] = FALSE;
        if (isset($form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD])) $form[LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD]['#access'] = FALSE;

        // UI wording for Issue report.
        if (isset($form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD])) {
          $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#title'] = t('Issue type');
          $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#description'] = t('Choose the issue you are reporting. "Damage" is one option.');
          $form[LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD]['#required'] = TRUE;
        }
        if (isset($form['field_library_inspection_notes'])) {
          $form['field_library_inspection_notes']['#title'] = t('Issue details');
          $form['field_library_inspection_notes']['#description'] = t('Briefly describe whatâ€™s wrong or missing.');
        }
        break;
    }
  }
  else {
    // No predefined action (admin create): restrict actions by state.
    if (isset($form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['widget']['#options']) && $item_details) {
      $allowed_actions = [];
      $original_options = $form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['widget']['#options'];
      switch ($item_details['status']) {
        case LENDING_LIBRARY_ITEM_STATUS_AVAILABLE:
          $allowed_actions[LENDING_LIBRARY_ACTION_WITHDRAW] = TRUE;
          break;
        case LENDING_LIBRARY_ITEM_STATUS_BORROWED:
        case LENDING_LIBRARY_ITEM_STATUS_MISSING:
          if ($item_details['borrower_uid'] == $current_user->id()) {
            $allowed_actions[LENDING_LIBRARY_ACTION_RETURN] = TRUE;
          }
          break;
      }
      $allowed_actions[LENDING_LIBRARY_ACTION_ISSUE] = TRUE;
      $new_options = [];
      if (isset($original_options['_none'])) $new_options['_none'] = $original_options['_none'];
      foreach (array_keys($allowed_actions) as $k) {
        if (isset($original_options[$k])) $new_options[$k] = $original_options[$k];
      }
      $form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['widget']['#options'] = $new_options;
      $form[LENDING_LIBRARY_TRANSACTION_ACTION_FIELD]['#disabled'] = (count($new_options) <= 1 && isset($new_options['_none'])) || count($new_options) === 0;
    }
  }

  // Battery widget visibility: only if item uses batteries AND action is withdraw.
  if (isset($form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD])) {
    $form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD]['#access'] = ($tool_requires_batteries && $current_action === LENDING_LIBRARY_ACTION_WITHDRAW);
  }

  // Attach JS limit when visible on Withdraw.
if (!empty($form[LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD]['#access'])
&& $current_action === LENDING_LIBRARY_ACTION_WITHDRAW) {
  $form['#attached']['library'][] = 'lending_library/battery_limit';
}


  // Button labels + force our submit handler (beats ECK default redirect).
  if (isset($form['actions']['submit'])) {
    switch ($current_action) {
      case LENDING_LIBRARY_ACTION_WITHDRAW:
        $form['actions']['submit']['#value'] = t('Confirm Withdrawal & Agree');
        break;
      case LENDING_LIBRARY_ACTION_RETURN:
        $form['actions']['submit']['#value'] = t('Confirm Return');
        break;
      case LENDING_LIBRARY_ACTION_ISSUE:
        $form['actions']['submit']['#value'] = t('Submit Report');
        break;
    }
    $form['actions']['submit']['#submit'][] = '_lending_library_transaction_form_submit';
    $form['actions']['submit']['#submit'][] = '_lending_library_check_for_damage_charge_submit';
  }

  if ($current_action === LENDING_LIBRARY_ACTION_WITHDRAW) {
    $due_date_display = t('N/A - Due date will be calculated upon withdrawal.');
    if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD)->isEmpty()) {
      $due_date_value_raw = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD)->value;
      if ($due_date_value_raw) {
        try {
          $due_date_object = DrupalDateTime::createFromFormat('Y-m-d', $due_date_value_raw);
          if ($due_date_object instanceof DrupalDateTime && empty(DrupalDateTime::getLastErrors())) {
            $due_date_display = \Drupal::service('date.formatter')->format($due_date_object->getTimestamp(), 'long');
          }
        }
        catch (\Exception $e) {
          // Leave default display.
        }
      }
    }

// --- AGREEMENT: config-only (withdraw action) --- //
$terms_html = \Drupal::config('lending_library.settings')->get('loan_terms_html');
if (empty($terms_html)) {
  // Safe fallback if config is empty or not installed yet.
  $terms_html = '<h4>Loan Terms</h4><ul>'
    . '<li><strong>Due Date:</strong> [due_date]</li>'
    . '<li>All tools must be returned within seven (7) days. Late fees apply.</li>'
    . '</ul>';
}

$replacement_value = $item_details['replacement_value'] ?? 0;
$config = \Drupal::config('lending_library.settings');
$non_return_percentage = ($config->get('non_return_charge_percentage') ?: 150) / 100;
$tool_replacement_charge = $replacement_value * $non_return_percentage;

$replacements = [
  '[due_date]' => $due_date_display,
  '[replacement_value]' => number_format($replacement_value, 2),
  '[tool_replacement_charge]' => number_format($tool_replacement_charge, 2),
  '[daily_late_fee]' => '$' . number_format($config->get('daily_late_fee') ?: 0, 2),
  '[late_fee_cap_percentage]' => $config->get('late_fee_cap_percentage') ?: 100,
];

$processed_terms = str_replace(array_keys($replacements), array_values($replacements), $terms_html);

$form['lending_library_agreement_text'] = [
  '#type' => 'markup',
  '#markup' => '<div class="lending-library-agreement">' . $processed_terms . '</div>',
  '#weight' => 50,
];

$form['lending_library_agreement_acknowledge'] = [
  '#type' => 'checkbox',
  '#title' => t('I acknowledge and agree to the terms stated above, including the due date and potential late fees.'),
  '#required' => TRUE,
  '#weight' => 51,
];
// --- END AGREEMENT ---


  }

  // Keep our validator too.
  $form['#validate'][] = '_lending_library_transaction_form_validate';
}

/**
 * Custom validation handler for library transaction forms.
 */
function _lending_library_transaction_form_validate(&$form, FormStateInterface $form_state) {
  $transaction_entity = $form_state->getFormObject()->getEntity();
  $action = '';
  if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->isEmpty()) {
    $action = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->value;
  }
  else {
    $action_value_item = $form_state->getValue(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD);
    $action = is_array($action_value_item) ? ($action_value_item[0]['value'] ?? NULL) : $action_value_item;
  }

  if ($action === LENDING_LIBRARY_ACTION_WITHDRAW) {
    if (!$form_state->getValue('lending_library_agreement_acknowledge')) {
      $form_state->setErrorByName('lending_library_agreement_acknowledge', t('You must acknowledge and agree to the terms before borrowing this tool.'));
    }

    $config = \Drupal::config('lending_library.settings');
    $current_user_id = \Drupal::currentUser()->id();
    $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->target_id);

    // Check for outstanding debt.
    if ($config->get('prevent_checkout_with_debt')) {
      $query = \Drupal::entityQuery('library_transaction')
        ->accessCheck(FALSE)
        ->condition(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD, $current_user_id)
        ->condition('field_library_charges_status', 'paid', '<>')
        ->condition('field_library_amount_due', 0, '>');
      $debt_transactions = $query->execute();
      if (!empty($debt_transactions)) {
        $form_state->setErrorByName('lending_library_agreement_acknowledge', t('You have outstanding debts and cannot borrow new items until they are paid.'));
      }
    }

    // Check for overdue items.
    if ($config->get('prevent_checkout_with_overdue')) {
      $now = new DrupalDateTime('now');
      $query = \Drupal::entityQuery('library_transaction')
        ->accessCheck(FALSE)
        ->condition(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD, $current_user_id)
        ->condition(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD, $now->format('Y-m-d'), '<')
        ->condition(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD, NULL, 'IS NULL');
      $overdue_transactions = $query->execute();
      if (!empty($overdue_transactions)) {
        $form_state->setErrorByName('lending_library_agreement_acknowledge', t('You have overdue items and cannot borrow new items until they are returned.'));
      }
    }

    // Check for max tool count.
    $max_tool_count = $config->get('max_tool_count');
    if (!empty($max_tool_count) && $max_tool_count > 0) {
      $query = \Drupal::entityQuery('node')
        ->accessCheck(FALSE)
        ->condition('type', LENDING_LIBRARY_ITEM_NODE_TYPE)
        ->condition(LENDING_LIBRARY_ITEM_BORROWER_FIELD, $current_user_id);
      $borrowed_count = $query->count()->execute();
      if ($borrowed_count >= $max_tool_count) {
        $form_state->setErrorByName('lending_library_agreement_acknowledge', t('You have reached the maximum number of borrowed items (@count).', ['@count' => $max_tool_count]));
      }
    }

    // Check for max tool value.
    $max_tool_value = $config->get('max_tool_value');
    if (!empty($max_tool_value) && $max_tool_value > 0) {
      $query = \Drupal::entityQuery('node')
        ->accessCheck(FALSE)
        ->condition('type', LENDING_LIBRARY_ITEM_NODE_TYPE)
        ->condition(LENDING_LIBRARY_ITEM_BORROWER_FIELD, $current_user_id);
      $borrowed_ids = $query->execute();
      $borrowed_value = 0;
      if (!empty($borrowed_ids)) {
        $borrowed_items = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($borrowed_ids);
        foreach ($borrowed_items as $borrowed_item) {
          if ($borrowed_item->hasField(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD) && !$borrowed_item->get(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD)->isEmpty()) {
            $borrowed_value += $borrowed_item->get(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD)->value;
          }
        }
      }

      $current_item_value = 0;
      if ($library_item_node->hasField(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD) && !$library_item_node->get(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD)->isEmpty()) {
        $current_item_value = $library_item_node->get(LENDING_LIBRARY_ITEM_REPLACEMENT_VALUE_FIELD)->value;
      }

      if (($borrowed_value + $current_item_value) > $max_tool_value) {
        $form_state->setErrorByName('lending_library_agreement_acknowledge', t('This item would exceed your maximum allowed total borrowing value ($@value).', ['@value' => $max_tool_value]));
      }
    }
  }

  if ($action === LENDING_LIBRARY_ACTION_RETURN) {
    $return_date_element_path = [LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD, 0, 'value'];
    $return_date_value_from_state = $form_state->getValue($return_date_element_path);
    if (empty($return_date_value_from_state)) {
      $today_datetime = new DrupalDateTime('now');
      $form_state->setValue($return_date_element_path, $today_datetime->format('Y-m-d'));
    }
    $return_image_value = $form_state->getValue(LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD);
    if (empty($return_image_value[0]['fids']) && empty($return_image_value[0]['target_id'])) {
      $form_state->setErrorByName(LENDING_LIBRARY_TRANSACTION_RETURN_IMAGE_FIELD, t('Return Inspection Image is required when returning an item.'));
    }
  }

  // Borrow/Return eligibility checks.
  $library_item_node = NULL;
  if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->isEmpty()) {
    $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->target_id);
  }
  if ($library_item_node instanceof NodeInterface) {
    $item_details = _lending_library_get_item_details($library_item_node);
    $current_user_id = \Drupal::currentUser()->id();
    if ($action === LENDING_LIBRARY_ACTION_WITHDRAW) {
      if ($item_details && $item_details['status'] !== LENDING_LIBRARY_ITEM_STATUS_AVAILABLE) {
        $form_state->setErrorByName(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, t('This item is not currently available for withdrawal. Its status is: @status.', ['@status' => $item_details['status']]));
      }
    }
    elseif ($action === LENDING_LIBRARY_ACTION_RETURN) {
      if ($item_details && !in_array($item_details['status'], [LENDING_LIBRARY_ITEM_STATUS_BORROWED, LENDING_LIBRARY_ITEM_STATUS_MISSING])) {
        $form_state->setErrorByName(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, t('This item cannot be returned. It is not currently marked as borrowed or missing.'));
      }
      elseif ($item_details && $item_details['borrower_uid'] != $current_user_id) {
        $form_state->setErrorByName(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, t('You are not the current borrower of this item.'));
      }
    }
  }
}

/**
 * Our submit handler (overrides ECK default so our redirect always applies).
 */
function _lending_library_transaction_form_submit(array &$form, FormStateInterface $form_state) {
  $transaction_entity = $form_state->getFormObject()->getEntity();
  if (!$transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD) || $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->isEmpty()) {
    return;
  }
  $action = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->value;

  $library_item_node = NULL;
  if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->isEmpty()) {
    $nid = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->target_id;
    if ($nid) {
      $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
    }
  }
  $tool_name = $library_item_node ? $library_item_node->label() : t('The tool');

  switch ($action) {
    case LENDING_LIBRARY_ACTION_WITHDRAW:
      \Drupal::messenger()->addStatus(t('@tool_name has been successfully withdrawn. Please remember to take the tool.', ['@tool_name' => $tool_name]));
      \Drupal::service('lending_library.manager')->sendCheckoutEmail($transaction_entity);
      $form_state->setRedirectUrl(Url::fromUri('internal:/library/borrowed'));
      break;

      case LENDING_LIBRARY_ACTION_RETURN:
        $borrower_uid = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)->target_id ?: \Drupal::currentUser()->id();
        $charge_applied = FALSE;

        // Check if the return is overdue and charge for unreturned batteries if so.
        $now = new DrupalDateTime('now');
        if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD) && !$transaction_entity->get(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD)->isEmpty()) {
          $now = $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD)->date;
        }

        $t_query = \Drupal::entityQuery('library_transaction')
            ->condition(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD, $library_item_node->id())
            ->condition(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD, $borrower_uid)
            ->condition(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, 'withdraw')
            ->sort('created', 'DESC')->range(0, 1)->accessCheck(FALSE);
        $t_ids = $t_query->execute();
        if (!empty($t_ids)) {
            $withdraw_transaction = \Drupal::entityTypeManager()->getStorage('library_transaction')->load(reset($t_ids));
            $due_date = $withdraw_transaction->get(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD)->date;
            if ($due_date < $now) { // Is overdue.
                $config = \Drupal::config('lending_library.settings');
                $late_fee_details = _lending_library_calculate_late_fee($withdraw_transaction, $now);
                $final_late_fee = 0;

                if ($late_fee_details) {
                    $item_details = _lending_library_get_item_details($library_item_node);
                    $replacement_value = $item_details['replacement_value'] ?? 0;
                    $cap_percentage = $config->get('late_fee_cap_percentage');
                    $fee_cap = ($replacement_value * $cap_percentage) / 100;
                    $final_late_fee = min($late_fee_details['late_fee'], $fee_cap);
                }

                if ($final_late_fee > 0) {
                    $transaction_entity->set('field_library_charge_overdue', $final_late_fee);
                    if ($transaction_entity->hasField('field_library_amount_due')) {
                        $transaction_entity->set('field_library_amount_due', $final_late_fee);
                    }
                    $email_params = [
                        'amount_due' => $final_late_fee,
                        'days_late' => $late_fee_details['days_late'] ?? 0,
                        'daily_fee' => $config->get('daily_late_fee'),
                        'late_fee_total' => $final_late_fee,
                    ];
                    \Drupal::service('lending_library.manager')->sendEmailByKey($transaction_entity, 'late_return_fee', $email_params);
                    $charge_applied = TRUE;
                }
            }

            // This needs to be a separate check from the late fee check.
            $unreturned_battery_charge = 0;
            if (!$form_state->getValue('lending_library_return_batteries')) {
                $unreturned_battery_charge = _lending_library_calculate_unreturned_battery_value($withdraw_transaction);
            }

            if ($unreturned_battery_charge > 0) {
                $transaction_entity->set('field_library_charge_battery', $unreturned_battery_charge);
                $current_due = $transaction_entity->hasField('field_library_amount_due') ? $transaction_entity->get('field_library_amount_due')->value : 0;
                $transaction_entity->set('field_library_amount_due', $current_due + $unreturned_battery_charge);
                \Drupal::service('lending_library.manager')->sendEmailByKey($transaction_entity, 'condition_charge', ['amount_due' => $unreturned_battery_charge]);
                $charge_applied = TRUE;
            }
        }

        \Drupal::messenger()->addStatus(t('@tool_name has been successfully returned. Thank you!', ['@tool_name' => $tool_name]));

        // Show put-back location if available.
        if ($library_item_node) {
          $loc_parts = [];
          if ($library_item_node->hasField('field_library_location_row_item') && !$library_item_node->get('field_library_location_row_item')->isEmpty()) {
            $loc_parts[] = t('Row: @row', ['@row' => $library_item_node->get('field_library_location_row_item')->value]);
          }
          if ($library_item_node->hasField('field_library_location_shelf_num') && !$library_item_node->get('field_library_location_shelf_num')->isEmpty()) {
            $loc_parts[] = t('Shelf: @shelf', ['@shelf' => $library_item_node->get('field_library_location_shelf_num')->value]);
          }
          if (!empty($loc_parts)) {
            \Drupal::messenger()->addStatus(t('Please put this item back at: @location', ['@location' => implode(', ', $loc_parts)]));
          }
        }

        // If the checkbox exists and is checked, return associated batteries.
        if ($form_state->getValue('lending_library_return_batteries') && $library_item_node instanceof \Drupal\node\NodeInterface) {
          $bats = _lending_library_load_borrowed_batteries($library_item_node->id(), $borrower_uid);
          if (!empty($bats)) {
            _lending_library_return_batteries($bats);
            \Drupal::messenger()->addStatus(t('Associated batteries have been marked as returned.'));
          }
        }
  
        if (!$charge_applied) {
          \Drupal::service('lending_library.manager')->sendReturnEmail($transaction_entity);
        }

        if ($library_item_node->hasField(LENDING_LIBRARY_ITEM_WAITLIST_FIELD) && !$library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->isEmpty()) {
          $waitlist_users = $library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->referencedEntities();
          $next_user = reset($waitlist_users);
          if ($next_user) {
            // Notify the next person in line, but do not remove them from the
            // waitlist. They will be removed when they borrow the item, or
            // they can choose to leave the waitlist.
            \Drupal::service('lending_library.manager')->sendEmailByKey($transaction_entity, 'waitlist_notification', ['next_user' => $next_user]);
          }
        }

        $form_state->setRedirectUrl(Url::fromUri('internal:/library'));
        break;
  

    case LENDING_LIBRARY_ACTION_ISSUE:
      \Drupal::messenger()->addStatus(t('Your issue report for @tool_name has been submitted.', ['@tool_name' => $tool_name]));
      if ($transaction_entity->hasField(LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD) && $transaction_entity->get(LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD)->value === 'damage') {
        \Drupal::service('lending_library.manager')->sendDamagedEmail($transaction_entity);
      }
      else {
        \Drupal::service('lending_library.manager')->sendIssueEmail($transaction_entity);
      }
      if ($library_item_node) {
        $form_state->setRedirectUrl($library_item_node->toUrl());
      }
      else {
        $form_state->setRedirectUrl(Url::fromUri('internal:/library'));
      }
      break;
  }
}


/**
 * Apply item (and battery) status changes after a transaction is saved.
 * Drop-in replacement for lending_library_entity_insert().
 */
function lending_library_entity_insert(EntityInterface $entity) {
  // Only handle Library Transaction inserts.
  if ($entity->getEntityTypeId() !== 'library_transaction' || $entity->bundle() !== 'library_transaction') {
    return;
  }

  // Must have item reference + action.
  if ($entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->isEmpty()
    || $entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->isEmpty()) {
    return;
  }

  $library_item_node_id = $entity->get(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD)->target_id;
  $action = $entity->get(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD)->value;
  $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($library_item_node_id);
  if (!$library_item_node instanceof NodeInterface || $library_item_node->bundle() !== LENDING_LIBRARY_ITEM_NODE_TYPE) {
    return;
  }

  // Borrower: prefer explicit field, otherwise creator/owner.
  $transaction_borrower_uid = $entity->getOwnerId();
  if ($entity->hasField(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)
    && !$entity->get(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)->isEmpty()) {
    $transaction_borrower_uid = $entity->get(LENDING_LIBRARY_TRANSACTION_BORROWER_FIELD)->target_id;
  }

  $save_item_node = FALSE;

  switch ($action) {

    // ---------------------------
    // WITHDRAW
    // ---------------------------
    case LENDING_LIBRARY_ACTION_WITHDRAW:
      $item_details = _lending_library_get_item_details($library_item_node);

      // Failsafe: If the item is being withdrawn but is still marked as
      // borrowed, it means a return was missed. We should close the previous
      // loan by creating a programmatic return transaction.
      if ($item_details['status'] === LENDING_LIBRARY_ITEM_STATUS_BORROWED && $item_details['borrower_uid'] && $item_details['borrower_uid'] != $transaction_borrower_uid) {
        $storage = \Drupal::entityTypeManager()->getStorage('library_transaction');
        $return_values = [
          'type' => 'library_transaction',
          'field_library_item' => $library_item_node->id(),
          'field_library_action' => LENDING_LIBRARY_ACTION_RETURN,
          'field_library_borrower' => $item_details['borrower_uid'],
          'uid' => $item_details['borrower_uid'], // Or system user (0)?
          'field_library_return_date' => date('Y-m-d\TH:i:s'),
          'field_library_inspection_notes' => 'Automatic return processed due to new withdrawal.',
        ];
        $programmatic_return = $storage->create($return_values);
        $programmatic_return->save();

        // Reload the node to get the updated status.
        \Drupal::entityTypeManager()->getStorage('node')->resetCache([$library_item_node->id()]);
        $library_item_node = \Drupal::entityTypeManager()->getStorage('node')->load($library_item_node->id());
      }

      // Now, proceed with the withdrawal.
      if ($transaction_borrower_uid) {
        // If the borrower is on the waitlist, remove them.
        if ($library_item_node->hasField(LENDING_LIBRARY_ITEM_WAITLIST_FIELD) && !$library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->isEmpty()) {
          $waitlist_items = $library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->getValue();
          foreach ($waitlist_items as $delta => $item) {
            if (isset($item['target_id']) && $item['target_id'] == $transaction_borrower_uid) {
              $library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->removeItem($delta);
              break;
            }
          }
        }

        // Update tool.
        $library_item_node->set(LENDING_LIBRARY_ITEM_STATUS_FIELD, LENDING_LIBRARY_ITEM_STATUS_BORROWED);
        $library_item_node->set(LENDING_LIBRARY_ITEM_BORROWER_FIELD, ['target_id' => $transaction_borrower_uid]);
        if ($library_item_node->hasField('field_item_available_since')) {
          $library_item_node->set('field_item_available_since', NULL);
        }
        $save_item_node = TRUE;

        // Update selected batteries to "borrowed".
        if ($entity->hasField(LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD)
          && !$entity->get(LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD)->isEmpty()) {

          $battery_target_ids = array_column($entity->get(LENDING_LIBRARY_TRANSACTION_BORROW_BATTERIES_FIELD)->getValue(), 'target_id');
          if (!empty($battery_target_ids)) {
            $batteries = \Drupal::entityTypeManager()->getStorage('battery')->loadMultiple($battery_target_ids);
            foreach ($batteries as $battery) {
              $previous_borrower_msg = '';
              // Check if we are 'stealing' the battery (it was borrowed by someone else).
              if ($battery->hasField(LENDING_LIBRARY_BATTERY_STATUS_FIELD) && $battery->get(LENDING_LIBRARY_BATTERY_STATUS_FIELD)->value === LENDING_LIBRARY_BATTERY_STATUS_BORROWED) {
                 if ($battery->hasField(LENDING_LIBRARY_BATTERY_BORROWER_FIELD) && !$battery->get(LENDING_LIBRARY_BATTERY_BORROWER_FIELD)->isEmpty()) {
                   $prev_uid = $battery->get(LENDING_LIBRARY_BATTERY_BORROWER_FIELD)->target_id;
                   if ($prev_uid != $transaction_borrower_uid) {
                     $previous_borrower_msg = " (Taken from user $prev_uid)";
                   }
                 }
              }

              if ($battery->hasField(LENDING_LIBRARY_BATTERY_STATUS_FIELD)) {
                $battery->set(LENDING_LIBRARY_BATTERY_STATUS_FIELD, LENDING_LIBRARY_BATTERY_STATUS_BORROWED);
              }
              if ($battery->hasField(LENDING_LIBRARY_BATTERY_BORROWER_FIELD) && $transaction_borrower_uid) {
                $battery->set(LENDING_LIBRARY_BATTERY_BORROWER_FIELD, ['target_id' => $transaction_borrower_uid]);
              }
              if ($battery->hasField(LENDING_LIBRARY_BATTERY_CURRENT_ITEM_FIELD)) {
                $battery->set(LENDING_LIBRARY_BATTERY_CURRENT_ITEM_FIELD, ['target_id' => $library_item_node->id()]);
              }
              \Drupal::service('lending_library.manager')->saveBatteryWithRevision(
                $battery,
                t('Borrowed with tool @tool (nid @nid) by user @uid.@note', [
                  '@tool' => $library_item_node->label(),
                  '@nid'  => $library_item_node->id(),
                  '@uid'  => $transaction_borrower_uid,
                  '@note' => $previous_borrower_msg,
                ])
              );

              \Drupal::service('lending_library.manager')->createBatteryTransaction(
                  $battery,
                  'withdraw',
                  $transaction_borrower_uid,
                  $entity
              );

            }
          }
        }
      }
      break;

    // ---------------------------
    // RETURN
    // ---------------------------
    case LENDING_LIBRARY_ACTION_RETURN:
      // Update tool status.
      $library_item_node->set(LENDING_LIBRARY_ITEM_STATUS_FIELD, LENDING_LIBRARY_ITEM_STATUS_AVAILABLE);
      $library_item_node->set(LENDING_LIBRARY_ITEM_BORROWER_FIELD, NULL);
      if ($library_item_node->hasField('field_item_available_since')) {
        $library_item_node->set('field_item_available_since', date('Y-m-d\TH:i:s'));
      }
      $save_item_node = TRUE;

      // Ensure return date is set on the transaction.
      if ($entity->hasField(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD) && $entity->get(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD)->isEmpty()) {
        $entity->set(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD, ['value' => (new DrupalDateTime('now'))->format('Y-m-d')]);
      }

      // Note: The logic to mark batteries as returned is in _lending_library_transaction_form_submit(),
      // based on user input from the form. The previous broad logic here was a bug.

      // If you added a "closed" boolean on transactions, mark it.
      if ($entity->hasField('field_library_closed')) {
        try { $entity->set('field_library_closed', 1); } catch (\Exception $ignore) {}
      }

      // Now, find the original withdraw (or renew) transaction(s) and close them.
      $query = \Drupal::entityQuery('library_transaction')
        ->condition('field_library_item', $library_item_node->id())
        ->condition('field_library_action', ['withdraw', 'renew'], 'IN')
        ->condition('field_library_closed', 1, '<>')
        ->sort('created', 'DESC')
        ->accessCheck(FALSE);
      $open_transaction_ids = $query->execute();

      if (!empty($open_transaction_ids)) {
        $open_transactions = \Drupal::entityTypeManager()->getStorage('library_transaction')->loadMultiple($open_transaction_ids);
        foreach ($open_transactions as $open_transaction) {
          if ($open_transaction->hasField('field_library_closed')) {
            $open_transaction->set('field_library_closed', 1);
          }
          if ($open_transaction->hasField(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD) && $entity->hasField(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD)) {
            // Only set return date if not already set? Or overwrite? Overwrite seems safer to sync.
            $open_transaction->set(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD, $entity->get(LENDING_LIBRARY_TRANSACTION_RETURN_DATE_FIELD)->value);
          }
          $open_transaction->save();
        }
      }
      break;

    // ---------------------------
    // ISSUE
    // ---------------------------
    case LENDING_LIBRARY_ACTION_ISSUE:
      $new_status_based_on_issue = NULL;
      if ($entity->hasField(LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD)
        && !$entity->get(LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD)->isEmpty()) {
        $issue_type = $entity->get(LENDING_LIBRARY_TRANSACTION_INSPECTION_ISSUES_FIELD)->value;
        switch ($issue_type) {
          case LENDING_LIBRARY_INSPECTION_MISSING:
            $new_status_based_on_issue = LENDING_LIBRARY_ITEM_STATUS_MISSING;
            break;

          case LENDING_LIBRARY_INSPECTION_DAMAGE:
          case LENDING_LIBRARY_INSPECTION_OTHER:
            $new_status_based_on_issue = LENDING_LIBRARY_ITEM_STATUS_REPAIR;
            break;

          case LENDING_LIBRARY_INSPECTION_NO_ISSUES:
            $new_status_based_on_issue = LENDING_LIBRARY_ITEM_STATUS_AVAILABLE;
            break;
        }
      }

      if ($new_status_based_on_issue) {
        $library_item_node->set(LENDING_LIBRARY_ITEM_STATUS_FIELD, $new_status_based_on_issue);
        // If an item is no longer borrowed (available or in for repair), clear the borrower.
        if (in_array($new_status_based_on_issue, [LENDING_LIBRARY_ITEM_STATUS_AVAILABLE, LENDING_LIBRARY_ITEM_STATUS_REPAIR])) {
          $library_item_node->set(LENDING_LIBRARY_ITEM_BORROWER_FIELD, NULL);
        }
        $save_item_node = TRUE;

        // If item marked Missing, optionally tag any linked borrowed batteries as Missing too.
        if ($new_status_based_on_issue === LENDING_LIBRARY_ITEM_STATUS_MISSING) {
          try {
            $query = \Drupal::entityQuery('battery')->accessCheck(FALSE);
            $defs = \Drupal::service('entity_field.manager')->getFieldDefinitions('battery', 'battery');
            if (isset($defs[LENDING_LIBRARY_BATTERY_STATUS_FIELD])) {
              $query->condition(LENDING_LIBRARY_BATTERY_STATUS_FIELD . '.value', LENDING_LIBRARY_BATTERY_STATUS_BORROWED);
            }
            if (isset($defs[LENDING_LIBRARY_BATTERY_CURRENT_ITEM_FIELD])) {
              $query->condition(LENDING_LIBRARY_BATTERY_CURRENT_ITEM_FIELD, $library_item_node->id());
            }
            $ids = $query->execute();
            if ($ids) {
              $bats = \Drupal::entityTypeManager()->getStorage('battery')->loadMultiple($ids);
              foreach ($bats as $battery) {
                if ($battery->hasField(LENDING_LIBRARY_BATTERY_STATUS_FIELD)) {
                  $battery->set(LENDING_LIBRARY_BATTERY_STATUS_FIELD, LENDING_LIBRARY_BATTERY_STATUS_MISSING);
                }
                \Drupal::service('lending_library.manager')->saveBatteryWithRevision(
                  $battery,
                  t('Marked MISSING because tool @tool (nid @nid) was reported missing.', [
                    '@tool' => $library_item_node->label(),
                    '@nid'  => $library_item_node->id(),
                  ])
                );


              }
            }
          } catch (\Exception $e) {
            \Drupal::logger('lending_library')->error('Error updating batteries on missing issue: @msg', ['@msg' => $e->getMessage()]);
          }
        }
      }
      break;
  }

  if ($save_item_node) {
    try {
      $library_item_node->save();
    }
    catch (\Exception $e) {
      \Drupal::logger('lending_library')->error(
        'Failed to save library item @nid after transaction: @msg',
        ['@nid' => $library_item_node->id(), '@msg' => $e->getMessage()]
      );
    }
  }

}

/**
 * Implements hook_cron().
 *
 * Finds overdue items and sends notifications or applies charges.
 */
function lending_library_cron() {
  $logger = \Drupal::logger('lending_library');
  $logger->notice('Lending library cron job started.');

  $now = new DrupalDateTime('now');
  $config = \Drupal::config('lending_library.settings');

  // Get all fee settings.
  $overdue_charge_days = $config->get('overdue_charge_days') ?: 30;
  $non_return_charge_percentage = $config->get('non_return_charge_percentage') ?: 150;
  $daily_late_fee = $config->get('daily_late_fee') ?: 10;
  $late_fee_cap_percentage = $config->get('late_fee_cap_percentage') ?: 50;
  $enable_overdue_notifications = $config->get('enable_overdue_notifications');

  // Find all items that are currently borrowed or missing.
  $query = \Drupal::entityQuery('node')
    ->condition('type', LENDING_LIBRARY_ITEM_NODE_TYPE)
    ->condition(LENDING_LIBRARY_ITEM_STATUS_FIELD, [LENDING_LIBRARY_ITEM_STATUS_BORROWED, LENDING_LIBRARY_ITEM_STATUS_MISSING], 'IN')
    ->accessCheck(FALSE);
  $item_ids = $query->execute();

  if (empty($item_ids)) {
    $logger->notice('Cron: No borrowed or missing items found.');
    return;
  }

  $items = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($item_ids);

  foreach ($items as $item) {
    // Get the latest 'withdraw' transaction for this item to find the due date.
    $t_query = \Drupal::entityQuery('library_transaction')
      ->condition(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD, $item->id())
      ->condition(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, 'withdraw')
      ->condition('field_library_return_date', NULL, 'IS NULL')
      ->condition('field_library_closed', 1, '<>')
      ->sort('created', 'DESC')
      ->range(0, 1)
      ->accessCheck(FALSE);
    $t_ids = $t_query->execute();
    if (empty($t_ids)) {
      continue;
    }
    $transaction = \Drupal::entityTypeManager()->getStorage('library_transaction')->load(reset($t_ids));

    if ($transaction->get(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD)->isEmpty()) {
      continue;
    }

    $due_date = $transaction->get(LENDING_LIBRARY_TRANSACTION_DUE_DATE_FIELD)->date;

    if ($due_date > $now) {
      // Not overdue yet. Check for due soon.
      $one_day_interval = new \DateInterval('P1D');
      $due_soon_threshold = (clone $now)->add($one_day_interval);

      if ($due_date < $due_soon_threshold) {
        // Due within 24 hours.
        if ($config->get('enable_due_soon_notifications')) {
          if ($transaction->hasField('field_library_due_soon_notified') && !$transaction->get('field_library_due_soon_notified')->value) {
            \Drupal::service('lending_library.manager')->sendDueSoonEmail($transaction);
          }
        }
      }
    }
    else {
      // Overdue.
      if (!$enable_overdue_notifications) {
        continue;
      }

      $days_overdue = $due_date->diff($now)->days;

      // Check if it's time for the final non-return charge.
      if ($days_overdue >= $overdue_charge_days) {
        if ($transaction->hasField('field_library_30day_processed') && $transaction->get('field_library_30day_processed')->value) {
          continue;
        }
        \Drupal::service('lending_library.manager')->processNonReturnCharge($transaction, $non_return_charge_percentage);
      }
      // Otherwise, if daily late fees are enabled, process them.
      elseif ($daily_late_fee > 0) {
        $item_details = _lending_library_get_item_details($item);
        $replacement_value = $item_details['replacement_value'] ?? 0;

        if ($replacement_value > 0) {
          $late_fee_cap = $replacement_value * ($late_fee_cap_percentage / 100);
          $cumulative_late_fee = $days_overdue * $daily_late_fee;
          $final_late_fee = min($cumulative_late_fee, $late_fee_cap);

          $current_amount_due = 0;
          if ($transaction->hasField('field_library_amount_due') && !$transaction->get('field_library_amount_due')->isEmpty()) {
              $current_amount_due = $transaction->get('field_library_amount_due')->value;
          }

          if ($final_late_fee > $current_amount_due) {
            $transaction->set('field_library_amount_due', $final_late_fee);
            if ($transaction->hasField('field_library_charge_overdue')) {
                $transaction->set('field_library_charge_overdue', $final_late_fee);
            }
            $transaction->save();

            if (!$transaction->hasField('field_library_overdue_notified') || !$transaction->get('field_library_overdue_notified')->value) {
              \Drupal::service('lending_library.manager')->sendEmailByKey($transaction, 'overdue_late_fee', [
                'amount_due' => $final_late_fee,
                'transaction_id' => $transaction->id(),
              ]);
              if ($transaction->hasField('field_library_overdue_notified')) {
                $transaction->set('field_library_overdue_notified', 1);
                $transaction->save();
              }
            }
          }
        }
      }
    }
  }

  // Waitlist cleanup.
  $waitlist_cleanup_days = $config->get('waitlist_cleanup_days');
  if ($waitlist_cleanup_days > 0) {
    $cleanup_interval = new \DateInterval("P{$waitlist_cleanup_days}D");
    $cleanup_threshold = (clone $now)->sub($cleanup_interval);

    $query = \Drupal::entityQuery('node')
      ->condition('type', LENDING_LIBRARY_ITEM_NODE_TYPE)
      ->condition(LENDING_LIBRARY_ITEM_STATUS_FIELD, LENDING_LIBRARY_ITEM_STATUS_AVAILABLE)
      ->condition('field_item_available_since', $cleanup_threshold->format('Y-m-d\TH:i:s'), '<=')
      ->accessCheck(FALSE);
    $item_ids_to_clear = $query->execute();

    if (!empty($item_ids_to_clear)) {
      $items_to_clear = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($item_ids_to_clear);
      foreach ($items_to_clear as $item) {
        if ($item->hasField(LENDING_LIBRARY_ITEM_WAITLIST_FIELD) && !$item->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->isEmpty()) {
          $item->set(LENDING_LIBRARY_ITEM_WAITLIST_FIELD, []);
          $item->set('field_item_available_since', NULL);
          $item->save();
          $logger->notice('Cleared waitlist for item @nid.', ['@nid' => $item->id()]);
        }
      }
    }
  }

  $logger->notice('Lending library cron job finished.');
}

/**
 * Processes a transaction for a non-returned item.
 * @deprecated Use \Drupal::service('lending_library.manager')->processNonReturnCharge() instead.
 */
/**
 * Calculates late fee for a transaction.
 * @deprecated Use \Drupal::service('lending_library.manager')->calculateLateFee() instead.
 */
function _lending_library_calculate_late_fee(EntityInterface $transaction, $return_date = NULL) {
  return \Drupal::service('lending_library.manager')->calculateLateFee($transaction, $return_date);
}

function _lending_library_process_non_return_charge(EntityInterface $transaction, $non_return_charge_percentage) {
  \Drupal::service('lending_library.manager')->processNonReturnCharge($transaction, $non_return_charge_percentage);
}

/**
 * Helper to send email based on a key.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendEmailByKey() instead.
 */
function _lending_library_send_email_by_key(EntityInterface $transaction, $key, $extra_params = []) {
  \Drupal::service('lending_library.manager')->sendEmailByKey($transaction, $key, $extra_params);
}

/**
 * Calculates the value of unreturned batteries for a transaction.
 * @deprecated Use \Drupal::service('lending_library.manager')->calculateUnreturnedBatteryValue() instead.
 */
function _lending_library_calculate_unreturned_battery_value(EntityInterface $transaction) {
  return \Drupal::service('lending_library.manager')->calculateUnreturnedBatteryValue($transaction);
}


/**
 * Implements hook_entity_view().
 */
function lending_library_entity_view(array &$build, EntityInterface $entity, \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display, $view_mode) {
  if ($entity->getEntityTypeId() === 'node' && $entity->bundle() === LENDING_LIBRARY_ITEM_NODE_TYPE && $view_mode === 'full') {
    $current_user = \Drupal::currentUser();
    $library_item_node = $entity;
    $item_details = _lending_library_get_item_details($library_item_node);

    if ($item_details) {
      $status_class = 'status-' . preg_replace('/[^a-z0-9\-]+/', '-', strtolower($item_details['status']));
      $status_markup = '<div class="lending-library-status ' . $status_class . '">';
      $status_markup .= '<strong>' . t('Status:') . '</strong> ' . ucfirst($item_details['status']);

      if ($item_details['status'] === LENDING_LIBRARY_ITEM_STATUS_BORROWED && $item_details['borrower_uid']) {
        if (!$current_user->isAnonymous()) {
          $borrower_account = User::load($item_details['borrower_uid']);
          if ($borrower_account) {
            $borrower_link = Link::fromTextAndUrl($borrower_account->getDisplayName(), $borrower_account->toUrl())->toString();
            $status_markup .= ' ' . t('by @username', ['@username' => $borrower_link]);

            $loan_details = _lending_library_get_current_loan_details($library_item_node);
            if ($loan_details) {
              $date_formatter = \Drupal::service('date.formatter');
              if (!empty($loan_details['borrow_date'])) {
                $status_markup .= '<br/><strong>' . t('Borrowed:') . '</strong> ' . $date_formatter->format($loan_details['borrow_date']->getTimestamp(), 'custom', 'F j, Y');
              }
              if (!empty($loan_details['due_date'])) {
                $status_markup .= '<br/><strong>' . t('Due:') . '</strong> ' . $date_formatter->format($loan_details['due_date']->getTimestamp(), 'custom', 'F j, Y');
              }
            }
          }
        }
      }
      $status_markup .= '</div>';
      $build['lending_library_status'] = [
        '#markup' => $status_markup,
        '#weight' => -10,
      ];
    }

    if (!$current_user->hasRole('borrower')) {
      return;
    }

    $links = [];
    if ($item_details) {
      if ($item_details['status'] === LENDING_LIBRARY_ITEM_STATUS_AVAILABLE) {
        $url = Url::fromRoute('lending_library.withdraw_form', ['node' => $library_item_node->id()]);
        $links['withdraw'] = ['#type' => 'link', '#title' => t('Withdraw This Item'), '#url' => $url, '#attributes' => ['class' => ['button', 'button--primary', 'lending-library-button']]];
      }
      if (in_array($item_details['status'], [LENDING_LIBRARY_ITEM_STATUS_BORROWED, LENDING_LIBRARY_ITEM_STATUS_MISSING]) && $item_details['borrower_uid'] == $current_user->id()) {
        $url = Url::fromRoute('lending_library.return_form', ['node' => $library_item_node->id()]);
        $links['return'] = ['#type' => 'link', '#title' => t('Return This Item'), '#url' => $url, '#attributes' => ['class' => ['button', 'button--primary', 'lending-library-button']]];

        // Add a "Renew" button.
        $config = \Drupal::config('lending_library.settings');
        $max_renewals = $config->get('max_renewal_count');
        $loan_details = _lending_library_get_current_loan_details($library_item_node);
        $now = new DrupalDateTime();

        // Get the renewal count from the latest transaction.
        $t_query = \Drupal::entityQuery('library_transaction')
          ->condition(LENDING_LIBRARY_TRANSACTION_ITEM_REF_FIELD, $library_item_node->id())
          ->condition(LENDING_LIBRARY_TRANSACTION_ACTION_FIELD, 'withdraw')
          ->sort('created', 'DESC')
          ->range(0, 1)
          ->accessCheck(FALSE);
        $t_ids = $t_query->execute();
        $renew_count = 0;
        if (!empty($t_ids)) {
          $transaction = \Drupal::entityTypeManager()->getStorage('library_transaction')->load(reset($t_ids));
          if ($transaction->hasField(LENDING_LIBRARY_TRANSACTION_RENEW_COUNT_FIELD) && !$transaction->get(LENDING_LIBRARY_TRANSACTION_RENEW_COUNT_FIELD)->isEmpty()) {
            $renew_count = $transaction->get(LENDING_LIBRARY_TRANSACTION_RENEW_COUNT_FIELD)->value;
          }
        }

        if ($loan_details['due_date'] > $now &&
            ($max_renewals == 0 || $renew_count < $max_renewals) &&
            (!$library_item_node->hasField(LENDING_LIBRARY_ITEM_WAITLIST_FIELD) || $library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->isEmpty())) {
          $url = Url::fromRoute('lending_library.renew', ['node' => $library_item_node->id()]);
          $links['renew'] = ['#type' => 'link', '#title' => t('Renew Item'), '#url' => $url, '#attributes' => ['class' => ['button', 'lending-library-button']]];
        }
      }
      if (in_array($item_details['status'], [LENDING_LIBRARY_ITEM_STATUS_BORROWED, LENDING_LIBRARY_ITEM_STATUS_REPAIR, LENDING_LIBRARY_ITEM_STATUS_MISSING]) && $library_item_node->hasField(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)) {
        $waitlist_users = $library_item_node->get(LENDING_LIBRARY_ITEM_WAITLIST_FIELD)->getValue();
        $user_ids = array_column($waitlist_users, 'target_id');
        if (in_array($current_user->id(), $user_ids)) {
          $url = Url::fromRoute('lending_library.waitlist_remove', ['node' => $library_item_node->id()]);
          $links['waitlist'] = ['#type' => 'link', '#title' => t('Leave Waitlist'), '#url' => $url, '#attributes' => ['class' => ['button', 'lending-library-button']]];
        }
        else {
          // Do not show "Get in Line" to the current borrower of the item.
          if ($item_details['borrower_uid'] !== $current_user->id()) {
            $url = Url::fromRoute('lending_library.waitlist_add', ['node' => $library_item_node->id()]);
            $links['waitlist'] = ['#type' => 'link', '#title' => t('Get in Line'), '#url' => $url, '#attributes' => ['class' => ['button', 'lending-library-button']]];
          }
        }
      }
      // START: "More actions" dropbutton section.
      $more_actions_links = [];

      // Always include "Report Issue" if the item is not retired.
      if ($item_details['status'] !== LENDING_LIBRARY_ITEM_STATUS_RETIRED) {
        $more_actions_links['report_issue'] = [
          'title' => t('Report Issue'),
          'url' => Url::fromRoute('lending_library.issue_form', ['node' => $library_item_node->id()]),
        ];
      }

      // Conditionally add "Mark as Available (On Shelf)" for administrators.
      if (\Drupal::currentUser()->hasPermission('administer lending library configuration') && $item_details['status'] !== LENDING_LIBRARY_ITEM_STATUS_AVAILABLE) {
        $more_actions_links['mark_available'] = [
          'title' => t('Mark as Available (On Shelf)'),
          'url' => Url::fromRoute('lending_library.mark_available', ['node' => $library_item_node->id()]),
          'attributes' => [
            'class' => ['use-ajax'],
            'data-dialog-type' => 'modal',
            'data-dialog-options' => json_encode(['width' => 700]),
          ],
        ];
      }

      // If there are any actions, create a dropbutton.
      if (!empty($more_actions_links)) {
        $links['more_actions_dropbutton'] = [
          '#type' => 'dropbutton',
          '#links' => $more_actions_links,
          '#weight' => 200,
        ];
      }
      // END: "More actions" dropbutton section.
    }

    if (!empty($links)) {
      // The rest of the build array remains the same.
      // The wrapper for lending_library_action-buttons also remains the same.

      $build['lending_library_actions'] = [
        '#type' => 'container',
        '#attributes' => ['class' => ['lending-library-action-buttons']],
        '#weight' => 100,
        'actions' => $links,
        '#prefix' => '<div class="lending-library-actions-wrapper">',
        '#suffix' => '</div>',
      ];
      $build['#attached']['library'][] = 'lending_library/lending_library.actions';
    }
  }
}

/**
 * Implements hook_library_info_build().
 */
function lending_library_library_info_build() {
  $libraries['lending_library.actions'] = [
    'css' => [
      'theme' => [
        'css/lending_library_actions.css' => [],
        'css/lending_library.css' => [],
      ],
    ],
  ];

  $libraries['lending_library.battery_limit'] = [
    'js' => [
      'js/battery_limit.js' => [],
    ],
    'dependencies' => [
      'core/drupal',
      'core/jquery',
    ],
  ];

  return $libraries;
}


/**
 * Save a Battery entity. If the entity type is revisionable, create a new revision;
 * otherwise just do a normal save.
 * @deprecated Use \Drupal::service('lending_library.manager')->saveBatteryWithRevision() instead.
 */
function _lending_library_battery_save_with_revision(EntityInterface $battery, $message = '', $uid = NULL) {
  \Drupal::service('lending_library.manager')->saveBatteryWithRevision($battery, $message, $uid);
}



/**
 * Process callback to add the 'capture' attribute to file inputs.
 */
function _lending_library_add_capture_attribute(&$element, FormStateInterface $form_state, &$complete_form) {
  if (isset($element['upload'])) {
    $element['upload']['#attributes']['capture'] = 'environment';
  }
  return $element;
}

/**
 * Sends a checkout confirmation email to the borrower.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendCheckoutEmail() instead.
 */
function _lending_library_send_checkout_email(EntityInterface $transaction_entity) {
  \Drupal::service('lending_library.manager')->sendCheckoutEmail($transaction_entity);
}

/**
 * Sends a return confirmation email to the borrower.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendReturnEmail() instead.
 */
function _lending_library_send_return_email(EntityInterface $transaction_entity) {
  \Drupal::service('lending_library.manager')->sendReturnEmail($transaction_entity);
}

/**
 * Sends an issue report notification to staff.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendStaffEmail() instead.
 */
/**
 * Sends an administrative email based on a transaction and email key.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendStaffEmail() instead.
 */
function _lending_library_send_staff_email($email_key, EntityInterface $transaction_entity, $address_config_key) {
  // We don't have a direct 1:1 for this private helper on the service public interface (it's protected),
  // but we can map the public calls to it.
  // However, for this deprecated function, we can't easily call the protected method.
  // So, we should probably keep the body here OR expose the protected method.
  // Let's expose it or just leave it for now as it's a helper.
  // Actually, issue/damage calls are public.
  // Let's check usages. It's used by issue and damaged below.
  // We'll deprecate those too.
}

/**
 * Sends an issue report notification to staff.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendIssueEmail() instead.
 */
function _lending_library_send_issue_email(EntityInterface $transaction_entity) {
  \Drupal::service('lending_library.manager')->sendIssueEmail($transaction_entity);
}

/**
 * Sends a damage report notification to staff.
 * @deprecated Use \Drupal::service('lending_library.manager')->sendDamagedEmail() instead.
 */
function _lending_library_send_damaged_email(EntityInterface $transaction_entity) {
  \Drupal::service('lending_library.manager')->sendDamagedEmail($transaction_entity);
}


/**
 * Implements hook_mail().
 * Uses site email as From and supports configurable message text.
 */
function lending_library_mail($key, &$message, $params) {
  // Ensure "From" is set to site email to satisfy SMTP providers.
  $site_from = \Drupal::config('system.site')->get('mail');
  if (!empty($site_from)) {
    $message['from'] = $site_from;
  }

  // Send as HTML.
  $message['headers']['Content-Type'] = 'text/html; charset=UTF-8';

  // Optional Reply-To support (pass 'reply_to' via $params from caller).
  if (!empty($params['reply_to'])) {
    $message['headers']['Reply-To'] = $params['reply_to'];
  }

  $cfg = \Drupal::config('lending_library.settings');

  // Generate payment link if applicable.
  if (isset($params['amount_due']) && $params['amount_due'] > 0) {
    $paypal_email = $cfg->get('paypal_email');
    if (!empty($paypal_email)) {
      $item_name_encoded = urlencode($params['tool_name'] . ' - Library Fee');
      $amount_encoded = urlencode($params['amount_due']);
      // The transaction ID is not available here directly, but can be passed in params.
      $custom_encoded = isset($params['transaction_id']) ? urlencode($params['transaction_id']) : '';
      $paypal_email_encoded = urlencode($paypal_email);
      $params['payment_link'] = "https://www.paypal.com/cgi-bin/webscr?cmd=_cart&business={$paypal_email_encoded}&lc=US&item_name={$item_name_encoded}&amount={$amount_encoded}&currency_code=USD&button_subtype=products&no_note=1&add=1&custom={$custom_encoded}&bn=PP-ShopCartBF%3Abtn_cart_SM.gif%3ANonHosted&no_shipping=1&tax_rate=0";
    }
  }

  // Centralized replacement logic.
  $replacements = [
    '[tool_name]' => $params['tool_name'] ?? '',
    '[borrower_name]' => $params['borrower_name'] ?? '',
    '[amount_due]' => isset($params['amount_due']) ? '$' . number_format($params['amount_due'], 2) : '',
    '[payment_link]' => $params['payment_link'] ?? '',
    '[tool_replacement_charge]' => isset($params['tool_replacement_charge']) ? '$' . number_format($params['tool_replacement_charge'], 2) : '',
    '[unreturned_batteries_charge]' => isset($params['unreturned_batteries_charge']) ? '$' . number_format($params['unreturned_batteries_charge'], 2) : '',
    '[replacement_value]' => isset($params['replacement_value']) ? '$' . number_format($params['replacement_value'], 2) : '',
    '[due_date]' => $params['due_date'] ?? '',
    '[issue_type]' => $params['issue_type'] ?? '',
    '[notes]' => $params['notes'] ?? '',
    '[reporter]' => $params['reporter'] ?? '',
    '[item_url]' => $params['item_url'] ?? '',
    '[return_image]' => $params['return_image_url'] ?? '',
    '[days_late]' => $params['days_late'] ?? '0',
    '[daily_fee]' => isset($params['daily_fee']) ? '$' . number_format($params['daily_fee'], 2) : '',
    '[late_fee_total]' => isset($params['late_fee_total']) ? '$' . number_format($params['late_fee_total'], 2) : '',
  ];

  $subject = '';
  $body_template = '';

  switch ($key) {
    case 'checkout_confirmation':
      $subject = $cfg->get('email_checkout_subject') ?: 'Tool Checkout Confirmation: [tool_name]';
      $body_template = $cfg->get('email_checkout_body') ?: "You have successfully checked out the following tool:\n\nTool: [tool_name]\nReplacement Value: [replacement_value]\nDue on or before: [due_date].";
      break;

    case 'return_confirmation':
      $subject = $cfg->get('email_return_subject') ?: 'Tool Return Confirmation: [tool_name]';
      $body_template = $cfg->get('email_return_body') ?: "Thanks! Your return has been recorded.\n\nTool: [tool_name]\n\nNotes:\n[notes]\n\nReturn Photo:\n[return_image]";
      break;

    case 'issue_report_notice':
      $subject = $cfg->get('email_issue_report_subject') ?: 'Lending Library Issue Report: [tool_name]';
      $body_template = $cfg->get('email_issue_report_body') ?: "A member submitted an issue report.\n\nTool: [tool_name]\nIssue type: [issue_type]\nDetails: [notes]\nReported by: [reporter]\nItem page: [item_url]";
      break;

    case 'due_soon':
      $subject = $cfg->get('email_due_soon_subject') ?: 'Your borrowed tool is due soon';
      $body_template = $cfg->get('email_due_soon_body') ?: "Hello [borrower_name],\n\nThis is a reminder that the tool '[tool_name]' you borrowed is due tomorrow. Please return it on time to avoid late fees.";
      break;

    case 'overdue_late_fee':
      $subject = $cfg->get('email_overdue_late_fee_subject') ?: 'Late fee added for overdue tool';
      $body_template = $cfg->get('email_overdue_late_fee_body') ?: "Hello [borrower_name],\n\nThe tool '[tool_name]' you borrowed is overdue. A late fee of [amount_due] has been applied to your account. Please return the tool as soon as possible to avoid further fees. You can pay the current balance here: [payment_link]";
      break;

    case 'overdue_30_day': // This key is kept for the non-return charge.
      $subject = $cfg->get('email_non_return_charge_subject') ?: 'Charge for unreturned library tool';
      $body_template = $cfg->get('email_non_return_charge_body') ?: "Hello [borrower_name],\n\nThe tool '[tool_name]' is now considered lost. You are being charged [amount_due] for its replacement. Please use the following link to pay: [payment_link]";
      break;

    case 'condition_charge':
      $subject = $cfg->get('email_condition_charge_subject') ?: 'Charge for tool damage or missing parts';
      $body_template = $cfg->get('email_condition_charge_body') ?: "Hello [borrower_name],\n\nA charge of [amount_due] has been added to your account for the tool '[tool_name]' due to its condition upon return. Please use the following link to pay: [payment_link]";
      break;

    case 'waitlist_notification':
      $subject = $cfg->get('email_waitlist_notification_subject') ?: 'A tool you are waiting for is now available';
      $body_template = $cfg->get('email_waitlist_notification_body') ?: "Hello [borrower_name],\n\nThe tool '[tool_name]' you were waiting for has been returned and is now available for checkout.";
      break;

    case 'damaged_item':
      $subject = $cfg->get('email_damaged_subject') ?: 'Damage Report: [tool_name]';
      $body_template = $cfg->get('email_damaged_body') ?: "A member has reported damage to a library item.\n\nTool: [tool_name]\nDetails: [notes]\nReported by: [reporter]\nItem page: [item_url]";
      break;

    case 'late_return_fee':
      $subject = $cfg->get('email_late_return_fee_subject') ?: 'Late Fee Charged for Tool Return';
      $body_template = $cfg->get('email_late_return_fee_body') ?: "Hello [borrower_name],\n\nThank you for returning '[tool_name]'. It was returned [days_late] days overdue.\n\nA late fee of [late_fee_total] has been charged to your account. Please use the following link to pay: [payment_link]";
      break;

    case 'renewal_confirmation':
      $subject = $cfg->get('email_renewal_confirmation_subject') ?: 'Tool Renewal Confirmation';
      $body_template = $cfg->get('email_renewal_confirmation_body') ?: "Hello [borrower_name],\n\nYou have successfully renewed '[tool_name]'. It is now due on [due_date].";
      break;
  }

  if (!empty($subject) && !empty($body_template)) {
    $message['subject'] = str_replace(array_keys($replacements), array_values($replacements), $subject);
    $message['body'][] = str_replace(array_keys($replacements), array_values($replacements), $body_template);
  }
}

/**
 * Helper to update tool status from a library transaction.
 */
function _lending_library_update_tool_status(EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'library_transaction') {
    /** @var \Drupal\lending_library\Service\ToolStatusUpdater $updater */
    $updater = \Drupal::service('lending_library.tool_status_updater');
    if ($updater) {
      $updater->updateFromTransaction($entity);
    }
  }
}

/**
 * Implements hook_entity_presave().
 */
function lending_library_entity_presave(EntityInterface $entity) {
  _lending_library_update_tool_status($entity);
}

/**
 * Implements hook_theme().
 */
function lending_library_theme($existing, $type, $theme, $path) {
  $module_path = \Drupal::service('extension.list.module')->getPath('lending_library');
  return [
        'lending_library_stats' => [
          'variables' => [
            'stats' => [],
            'charts' => [],
          ],
          'template' => 'lending-library-stats',
          'path' => $module_path . '/templates',
        ],
                    'lending_library_dashboard' => [
                      'variables' => [
                        'stats' => [],
                        'triggers' => [],
                        'recent_activity' => [],
                        'grouped_links' => [],
                        'due_soon_items' => [],
                        'overdue_items' => [],
                        'debtors' => [],
                        'key_stats' => [],
                        'damaged_items' => [],
                      ],
                      'template' => 'lending-library-dashboard',
                      'path' => $module_path . '/templates',
                    ],
                
                  ];
    }
    
